[] Algoritmer relaterade till RSA
    () ModulÃ¤r exponentiering   (gammalt(?, Matematik diskret))
    () Kinesiska restsatsen     (nytt)
    () Primalitetstestning      (gammalt, Matematik diskret)




PreliminÃ¤r version av hemtal A upplagt pÃ¥ hemsidan.
(mÃ¥ste rÃ¤tta â‰¥ 1 feltryck)

    gcd (a, b):
        â‹®
        else
            return gcd(b, a âˆ’ b)

InlÃ¤mning i bÃ¶rjan fÃ¶relÃ¤sning nÃ¤sta vecka.



RSA:

    n â† pâ‹…q
    e, d    eâ‹…d â‰¡ 1 (mod (p âˆ’ 1)(q âˆ’ 1))
    m âˆˆ â„¤_n

    â¡c = mâ†‘e    (mod n)
    â£m = câ†‘d    (mod n)


    BerÃ¤kna aâ†‘b mod n
    a, b, n Ã¤r t-bitars tal
    t = 1000

    aâ‹…aâ‹…aâ‹…â€¦â‹…a   (mod n)
    {        b        }

    b ~ 2â†‘t


    b = Î£[i = 0 â†’ tâˆ’1] b_iâ‹…2^i      bâ‚€ â€¦ b_{tâˆ’1}            a
                                                            aÂ²
    a^b = Î [b_i = 1 â†’ t] aâ†‘bâ†‘iâ†‘{aâ†‘[x + y] = aâ†‘x aâ†‘y}        (aÂ²)Â²


    p â† 1                   â«
    for i â† 0 to t âˆ’ 1      â®                   â€Snabb multiplikationâ€
        if b_i = 1          â®                   ğ“(tâ†‘(1+Îµ)) = ğ“(t â‹… log t â‹… log log t)   Bygger pÃ¥ snabba Fouriertransformer
            p â† pâ‹…a  (mod n)â¬ ğ“(t)
        a â† aâ‹…a  (mod n)    â®
       //p = aâ†‘b            â®
    return p (mod n)        â­



    n = a â‹… b   gcd(a, b) = 1

    x âˆˆ â„¤_n â†’  â„¤_a Ã— â„¤_b

        f(x) = (x mod a, x mod b)


    (3 â‹… 13) mod 20 = 19
    (3, 3) â‹… (1, 3) = (3, 9 mod 5) = (3, 4)


    Ring-isomorfi:              (se Matematik fÃ¶rdjupning)

                â„¤_20 = 3â‹…13     â†’   19

                      t â†“            â†“ t

           â„¤_4 Ã— â„¤_5   (3,3)(1,3) â†’  (3, 4)


    (mâ†‘e)â†‘d â‰¡ m     (mod n)

            â‡•

    (mâ†‘e)â†‘d â‰¡ m     (mod p, q)



    â§ x â‰¡ râ‚  (mod a)               gcd(a, b) = 1
    â¨                               ua + vb = 1
    â© x â‰¡ râ‚‚  (mod b)

    (uarâ‚‚ + vbrâ‚‚)   (mod n)
    {     â‰¡â†“    }

        â‰¡ 0 + vbrâ‚ (mod a) â‰¡ (1 âˆ’ ua)râ‚ â‰¡ râ‚ (mod a)


    mâ†‘ed â‰¡ m (mod n)            n = pq

    x â‰¡ mâ†‘ed

    x â‰¡ m   (mod n)

        â†“

    (x mod p, x mod q) = (m mod p, m mod q)



    mâ†‘ed â‰¡ m    (mod p)                     Fermats lilla sats  (se fÃ¶rra fÃ¶relÃ¤sningen, Matematik diskret, Matematik fÃ¶rdjupning)

    Om m â‰¡ 0 (mod p)                                Om p Ã¤r primtal och sgd(a, p) = 1
                                                        aâ†‘(p âˆ’ 1) â‰¡ 1 (mod p)
        sÃ¥ 0â†‘ed â‰¡ 0 (mod p)

    Om m â‰¢ 0 (mod p)
                                            ed = 1 + kâ†‘{(p âˆ’ 1)(q âˆ’ 1)}
        gcd(m, p) = 1
                                            mâ†‘ed = m â‹… mâ†‘{k(p âˆ’ 1)(q âˆ’ 1)} = m â‹… (mâ†‘(p âˆ’ 1))â†‘(q âˆ’ 1) â‰¡ m (mod p)
        mâ†‘(pâˆ’1) â‰¡ 1 (mod p)                                                      {â‰¡ 1 mod p}




    â„¤*_n = {x | x âˆˆ â„¤_n, gcd(x, n) = 1}

        x â‹… xâ»Â¹ â‰¡ 1  (mod n)

        |â„¤*_n| = (p âˆ’ 1)(q âˆ’ 1)

        m âˆˆ â„¤*_n

        mâ†‘|â„¤*_n| = 1




Fermats

    Om p Ã¤r primtal och gcd(a, p) = 1
    sÃ¥ aâ†‘(p âˆ’ 1) â‰¡ 1  (mod p)



n = pâ‹…q                         (Matematik diskret)

eâ‹…d â‰¡ 1 mod (p âˆ’ 1)(q âˆ’ 1)

c = mâ†‘e     (mod n)

m = câ†‘d     (mod n)


Hur hittar man e och d?

    VÃ¤lj slumpvis e dÃ¤r gcd(e, (p âˆ’ 1)(q âˆ’ 1)) = 1
    FÃ¶rsÃ¶k igenom om det inte uppfylldes.

    AnvÃ¤nd egcd (Euklides' utvigdade algoritm) fÃ¶r att hitta u, v

        ue + v(p âˆ’ 1)(q âˆ’ 1) = 1

        u = d


Vill ha primtal p med 1000 bitar.

    VÃ¤lj slumpvis udda tal z med t bitar.

    Kolla om primtal.
    Om inte, gÃ¶r om


    LÃ¥t Î (n) = #primtal â‰¤ n
    Î (n) â‰ˆ n / mn

    Inte ofantligt mycket.


Fermat-test av om n Ã¤r primtal         (Matematik diskret) 

    VÃ¤lj a (slumpvis)

        2 â‰¤ a â‰¤ n âˆ’ 1

    Kontrollera om aâ†‘{n âˆ’ 1} â‰¡ 1 (mod n)

        Om n Ã¤r primtal och 2 â‰¤ a â‰¤ n âˆ’ 1 sÃ¥
        gcd(a, n) = 1.
        SÃ¥ enligt Fermat aâ†‘{n âˆ’ 1} â‰¡ 1 (mod n)

    Om aâ†‘{n âˆ’ 1} â‰¢ 1  (mod n)   sÃ¥ sammansatt
    Om aâ†‘{n âˆ’ 1} â‰¡ 1  (mod n)   sÃ¥ kanske primtal


    n Ã¤r sammansatt

    â„¤*_n = {x âˆˆ â„¤_n | gcd(n, x) = 1}

    B = {b âˆˆ â„¤*_n | bâ†‘{n âˆ’ 1} â‰¡ 1 mod n}

    Anta att c âˆˆ â„¤*_n och att câ†‘{n âˆ’ 1} â‰¢ 1 (mod n)

    Bilda A = {câ‹…b | b âˆˆ B}

    (câ‹…b)â†‘{n âˆ’ 1} = câ†‘{n âˆ’ 1} â‹… bâ†‘{n âˆ’ 1} â‰¡ câ†‘{n âˆ’ 1} â‹… 1 â‰¢ 1


        â„¤*_n lite mindre Ã¤n â„¤_n,    B Ã¤r som mest halva â„¤*_n
        â„¤_n \ â„¤*_n âˆ‹ aâ†‘{n âˆ’ 1} â‰¢ 1


    (â„¤*_n, â‹…) Ã¤r en grupp
    (B, â‹…) Ã¤r en grupp
    B Ã¤r en delgrupp av â„¤*_n

        |B| \ |â„¤*_n|


    Problem         (Matematik diskret)

        Det finns s.k. Carmichael-tal, n, sÃ¥ att

        aâ†‘{n âˆ’ 1} â‰¡ 1 mod a âˆ€ a : gcd(a, n) = 1



//Itererara med olika a
ProbablyPrime(a, n)         Millerâ€“Rabin    (Matematik diskret)

    // n âˆ’ 1 = 2â†‘tâ‹…n dÃ¤r n Ã¤r udda

    xâ‚€ â† aâ†‘u (mod n)                                aâ†‘u     aâ†‘{n âˆ’ 1} = (aâ†‘n)â†‘2â†‘t

    for i = 1 to t

        x_i â† (x_{i âˆ’ n})Â² mod n

        if x_i = 1 and x_{iâˆ’1} â‰¢ âˆ’1 mod n       (x_{iâˆ’1} â‰  n âˆ’ 1)

            return COMPOSITE

    if x_t â‰  1
        return COMPOSITE
    else
        return MAYBE PRIME



    xÂ² â‰¡ 1  har rÃ¶tterna 1, âˆ’1 mod p om p Ã¤r ett primtal

    xÂ² â‰¡ 1 mod 7    1, 6

        Om n = pâ‹…q fÃ¶r udda primtal p, q sÃ¥ har  xÂ² â‰¡ 1 mod n  4 rÃ¶tter



