Aritmetik pÃ¥ stora heltal â€“ algebra, algoritmer och assembly

    TorbjÃ¶rn Granlund
    
    Kommer finnas pÃ¥ nÃ¤tet



DEL 1   Optimering
    


Vektyg 1:  Algebra. Exempel: RSA-signering

    Vi ska berÃ¤kna RSA-n (i tid ğ“(nÂ³))
    
            s = mâ†‘d mod pq
            
    dÃ¤r p och q Ã¤r primtal, och n = log pq â‰ˆ log m â‰ˆ log d
    
    SÃ¤tt d_p = d mod (p âˆ’ 1) och d_q = d mod (q âˆ’ 1).
    
UtfÃ¶r sedan de tvÃ¥ exponentieringarna:

    s_p = (m mod p)^{d_p} mod p
    s_q = (m mod q)^{d_q} mod q

Sedan ges s med CRT frÃ¥n s_p och s_q (i tid ğ“(nÂ²)).



Vektyg 2:  Effektiva algoritmer

    Exempel:
    Karatsubas dekompositionsalgoritm fÃ¶r multiplikation.
    
        U = 2â†‘{n/2} Uâ‚ + Uâ‚€
        V = 2â†‘{n/2} Vâ‚ + Vâ‚€
        
    UV = (2â†‘n )


Vektyg 3:  Aloritmval efter operandstorlek (1)

    Naiv Karatsuba-implementation:
    
    mul (word *w, word *u, word *v, size_t n)
    {
        if (n == 1)                     // if (n < 17)              //(2)
            w[0] = u[0] * v[0];         //     mul_skolbok (w, u, v, n);
        else /*Karatsuba code*/
            U1 = u + n/2;
            U0 = u
            V1 = v + n/2;
            V0 = v;
            
            mul (P0, U1, V1, n / 2);
            mul (P1, U0, V0, n / 2);
            mul (Ud, U0, V0, n / 2);    //sub ..............................
            
            ................................................
    }


Vektyg 3 (3):

    Resultat:
    
        Naiva Karatsuba-koden Ã¤r enligt mina tester snabbare Ã¤n
        skolboksmultiplikation frÃ¥n 8000 bitar (cd 2400 decimaler)


Verktyg 4:  Minnes- och cache-lokalitet

    > Temporal lokalitet
    > Spatial lokalitet
    > Data layout, padding
    
    Algoritmegenskap: Dekompositionsalgoritmer har god lokalitet.
    

Vektyg 5:  Utryllning av loppar

    for (i = 0; i < n; i++)
        jobbenhet
 
    
    for (i = 0; i < n; i += 4)  //se till att gÃ¶ra rÃ¤tt nÃ¤r 4 inte delar n.
        jobbenhet
        jobbenhet
        jobbenhet
        jobbenhet       ((inte alltid optimalt i Java))


Verktyg 6:  Software pipelining (1)

    MÃ¥l: Hantera fÃ¶rdrÃ¶jningar (latency) fÃ¶r operation.
    
    ................


Verktyg 5 + 6:

    Kombinera utrulllning och software pipelining


Verktyg 7:  â€Grundifieringâ€ av rekurrenser (1)

    Definition: Rekurrens = beroende mellan loopsteg.
    
    I bignum-kod: Olika varianter av propagering av minnessiffra (â€carryâ€)
    
    PÃ¥stÃ¥ende: Har vi k operationer fÃ¶r att generera utdata fÃ¶r en rekurrens
    frÃ¥n det att vi konsumerar indata fÃ¶r rekurrensen, ......................
    
    
Verktyg 7 (2):

    Ganska djup rekurrens:
    
    add (word *r, word *u, word *v, size_t n)
    {
        cy = 0
        for (i = 0; i < n; i++)
        {
            uword = u[i];
            vword = v[i];
            sum0 = uword + cy;
            cy0 = sum0 < uword; //underflow     //kan kÃ¶ras parallellt med nÃ¤sta rad
            sum1 = sum0 + vword; 
            cy1 = sum1 < sum 0;
            cy = cy0 + cy1;
            r[i] = sum1;
        }
    }
    
    
Verktyg 7 (3):

    Ganska djup rekurrens:
    
    add (word *r, word *u, word *v, size_t n)
    {
        cy = 0
        for (i = 0; i < n; i++)
        {
            uword = u[i];
            vword = v[i];
            sum0 = uword + vword;
            cy0 = sum0 < uword;
            sum1 = sum0 + cy; 
            cy1 = sum1 < sum 0;
            cy = cy0 + cy1;
            r[i] = sum1;
        }
    }
    
    
Verktyg 7 (3):

    Ganska djup rekurrens:
    
    add (word *r, word *u, word *v, size_t n)
    {
        cy = 0
        for (i = 0; i < n; i++)
        {
            uword = u[i];
            vword = v[i];
            sum0 = uword + vword;
            cy0 = sum0 < uword;
            sum1 = sum0 + cy;                           //kan kÃ¶ras parallellt med nÃ¤sta rad
            cy1 = cy & (sum0 == ~0); // ((~0 = âˆ’1))
            cy = cy0 + cy1;
            r[i] = sum1;
        }
    }


Verktyg 8:  Assembly

    Implementerar i assembly!
    
        > Leta anvÃ¤ndbara instruktioner
        > Designa mikro-algoritmer efter tillgÃ¤ngliga instruktioner
        > Ta hÃ¤nsyn till fÃ¶rdrÃ¶jning fÃ¶r vald intruktioner
        > Vilka instruktioner kan utfÃ¶ras parallellt?
        > Alignment
        > Trial-and-measure
        > Trial-and-measure
        > ...


Verktyg 9:  Av-hoppning (debranching)

    Villkorliga hopp av tvÃ¥ sorter:
    
        1:  Prediktabla
        2:  SlumpmÃ¤ssiga (eller av andra skÃ¤l icke-prediktabla)
    
    Ett icke-prediktablet hopp kostar som kanske 30 andra instruktioner.

    
    Ta bort hopp, kanske genom maskning.        ((inte alltid optimalt i Java))




DEL 2:  GMP


.............................................



