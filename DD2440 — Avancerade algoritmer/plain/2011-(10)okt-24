[] Om hemtal A
[] Faktorisering, "naivt"
[] Pollard-rho
[] xÂ² â‰¡ yÂ² (mod n)



Problem 1

    a = 2^r u,  b = 2^s v,  gcd(a, b) = 2^min(r,s) gcd(u, b)
    alg first extracts min(r,s) factors 2 then it removes any
    extra 2s. Always d|a, d|b â†’ d|(aâˆ’b),  and
        d|b, d|(aâˆ’b) â†’ d(aâˆ’b+b)



Problem 1 (cont.)

    If at least one is, then divide at least one with 2 within 2 rounds
    
    If both oss, then (a âˆ’ b) is even, so one even within two rounds.
    At least one divison by 2 at least every fourth ................



Problem 2

    Can use Chinese remainder theorem since gcd(N, N + 1) = 1
    
    "Just do it"
    
    Don't forget to say what X is
    
    Be safe: check your results



Problem 3

    Briefly: Do a radix sort in base n rather than 2
    
    Explain what that means

    Explain why it yeilds an ğ“(n) algorithm



Problem 3 (cont.)

    sort(x):    //X has n elements
        d = 1
        for i = 0 to 10:
            for j = 0 to n; L_j = []
            for x in X:
                j = (x div d) mod n
                L_j.addLast(X)
            X = concat(L_1, .., L_{n-1})
            d = d * n
        return X


Problem 4

    Briefly: Insert elements into balanced binary search tree (e.b. red:en:black)
    
    For each value, keep a counter or linked list of elements with that value
    
    Tree has at most m nodes, so insert n elements takes time ğ“(n log m)
    
    Do in-order traversal of tree to get result in ğ“(n)
            ğ“(m) for only listing
    
    Total time ğ“(n log m)



Problem 5

    Important observation 1: There are no more than 4nÂ² distinct clauses of size 1 or 1 with n variables
    
    Important observation 2: resolving two clauses of size â‰¤ 2 yields another clause of size â‰¤ 2
    
    For all paris of clauses f,h in C, if f and g can be resolved to h, add h to C (ğ“(mâ´) per round)
    
    Repeat until we get a contraction or no new clauses can be formed (ğ“(nÂ²) rounds)



Problem 5 (cont.)

    Resolution of f and g to get h DOES NOT remove f and g from the set of clauses
    
    The task was to analyse solving 2SAT with resolution, not by DPLL or some other algorithm.






Faktorisering

    N = Î  pâ†“iâ†‘{Î±_i}
    
    naiv faktorisering
    
        testa atta dividera med allt stÃ¶rre primtal
        
        RÃ¤cker testa primtal â‰¤ âˆšN
        
        AnvÃ¤nd primtalssÃ¥ll fÃ¶r att generera alla primtal â‰¤ B
    
    isprime[i] initieras till true
    
        [f|f|t|t|f| |f| |f|f]
         0 1 2 3 4 5 6 7 8 9

    VÃ¤lj slumpvis xâ‚, â€¦, x_t âˆˆ â„¤_N
    
        Hoppas att nÃ¥got par i < j      x_i â‰¡ x_j (mod p)
        
                        fÃ¶r nÃ¥got       p|N   (p primtal)
                        
        p|(x_i âˆ’ x_j), Nâˆ¤(x_i âˆ’ x_j)    x_i â‰¢ x_j (mod N)
        
        d = gcd(x_i âˆ’ x_j, N)    d < N, p|d
        
        LÃ¥t p vara minsta primtal som delar N
        
        Vi vÃ¤ljer xâ‚, â€¦, x_t
        
        Hur stort ska t vara fÃ¶r att vi med god sannolikhet ska
        ha x_i â‰¡ x_j (mod p) fÃ¶r nÃ¥got par i < j?
        
        (Om N inte Ã¤r primtal sÃ¥ p â‰¤ âˆšN)
        
        FÃ¶delsedagsparadoxen:   Om t â‰¥ âˆš{2p} sÃ¥ Ã¤r sannolikheten
                                att det finns x_i â‰¡ x_j (mod p) â‰¥ Â½
        
        
        God nyhet:  behÃ¶ver bara ğ“(âˆœN) vÃ¤rden x.
        
        DÃ¥lig nyhet:    kolla alla par tar tid  (t Ã¶ver 2) par   Î˜(tÂ²)    Î˜(âˆšN)
        
        
        
    Pollard-rho     f(x) = xÂ² + 1
    StartvÃ¤rde xâ‚€   x_i = f(x_{iâˆ’1}) mod N
    
    Pollard(N, xâ‚€)
        x1 â† f(xâ‚€) mod N
        x2 â† f(f(xâ‚€)) mod N
        
        while gcd(x2 âˆ’ x1, N) = 1
            x1 â† f(x1) mod N
            x2 â† f(f(x2)) mod N
        d â† gcd(x2 âˆ’ x2, N)
        return d
    
    
    Titta pÃ¥ x1 med p fÃ¶r p|N
    
        y_i = x_i (mod p)
                               â†™ â† â† â†–
                             â†™         â†–
                            â†“           â†‘
                            â†“           â†‘                   (rho-format)
        yâ‚€ â†’ yâ‚ â†’ yâ‚‚ â†’ â€¦ â†’ y_i â†’ â€¦ â†’ y_{tâˆ’1}
        
        
        
    
    
    aÂ² â‰¡ bÂ²  (mod N)
    a â‰¢ Â±b   (mod N)
    
    N = 65      4 â‰¡ 2Â² â‰¡ 63Â² â‰¡ 28Â² â‰¡ 37Â²    (mod 65)
    
    xÂ² â‰¡ c  (mod p)
    
    
    aÂ² âˆ’ bÂ² â‰¡ 0   (mod N)       N | (a âˆ’ b)(a + b)
    
    a â‰¢ b   (mod N)     N âˆ¤ (a âˆ’ b)
    a â‰¢ âˆ’b  (mod N)     N âˆ¤ (a + b)
    
    1 < gcd(a âˆ’ b, N), gcd(a + b, N) < N
    
    
    
    
    Metod frÃ¥n Fermat
    
    BerÃ¤kna qÂ² (mod N) = C och hoppas att c Ã¤r kvadrat Ã¶ver heltalen
    
    N = 65      q = 37
                qÂ² mod 65 = 4 = 2Â²
                37Â² â‰¡ 2Â² (mod 65)
                gcd(35, 65) = 5
                
    VÃ¤lj q pÃ¥ formen âŒˆâˆš{aN}âŒ‰ + b        a, b smÃ¥ heltal
    
        qÂ² (âˆš{aN} + b)Â² = aN + 2âˆš{aN}â‹…b + bÂ²
                        â‰¡ 2âˆš{aN}â‹…b + bÂ²
                        ~ âˆšN


